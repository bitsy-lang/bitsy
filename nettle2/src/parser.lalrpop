use super::*;

grammar;

pub Expr: Box<Expr> = {
    <e:ExprOr> => e,
}

pub ExprOr: Box<Expr> = {
    <e1:ExprAnd> "||" <e2:ExprOr> => Box::new(Expr::BinOp(BinOp::Or, e1, e2)),
    <e:ExprAnd> => e,
}

pub ExprAnd: Box<Expr> = {
    <e1:ExprNot> "&&" <e2:ExprAnd> => Box::new(Expr::BinOp(BinOp::And, e1, e2)),
    <e:ExprNot> => e,
}

pub ExprNot: Box<Expr> = {
    "!" <e:ExprEq> => Box::new(Expr::UnOp(UnOp::Not, e)),
    <e:ExprEq> => e,
}

pub ExprEq: Box<Expr> = {
    <e1:ExprAdd> "==" <e2:ExprEq> => Box::new(Expr::BinOp(BinOp::Eq,  e1, e2)),
    <e1:ExprAdd> "!=" <e2:ExprEq> => Box::new(Expr::BinOp(BinOp::Neq, e1, e2)),
    <e:ExprAdd> => e,
}

pub ExprAdd: Box<Expr> = {
    <e1:ExprBase> "+" <e2:ExprAdd> => Box::new(Expr::BinOp(BinOp::Add, e1, e2)),
    <e1:ExprBase> "-" <e2:ExprAdd> => Box::new(Expr::BinOp(BinOp::Sub, e1, e2)),
    <e:ExprBase> => e,
}

pub ExprBase: Box<Expr> = {
    <e:ExprLit> => e,
    <e:ExprTerminal> => e,
    "(" <e:Expr> ")" => e,
}

pub ExprLit: Box<Expr> = {
    "X" => Box::new(Expr::Lit(Value::X)),
    "true" => Box::new(Expr::Lit(Value::Bit(true))),
    "false" => Box::new(Expr::Lit(Value::Bit(false))),
    <lit:r"[0-9]+w[0-9]+"> => {
        let parts = lit.split("w").collect::<Vec<_>>();
        let v = parts[0].parse().unwrap();
        let width = parts[1].parse().unwrap();
        Box::new(Expr::Lit(Value::Word(width, v)))
    },
}

pub ExprTerminal: Box<Expr> = {
     <id:Id> => Box::new(Expr::Terminal(id))
}

pub Nat: u64 = {
    <n:r"[0-9]+"> => n.parse().unwrap(),
}

pub Id: String = {
     <id:r"[_A-Za-z][_A-Za-z0-9]*"> => id.to_string()
}

match {
    r"//[^\n\r]*[\r\n]" => {},
    r"[\r\n]*" => {},
    r"/\*[^*]*\*/" => {},
    r" " => {},
    _,
}

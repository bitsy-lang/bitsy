mod core {
    ext instr_mem {
        incoming read_addr of Word<16>;
        outgoing read_data of Word<8>;

        incoming write_enable of Word<1>;
        incoming write_addr of Word<16>;
        incoming write_data of Word<8>;
    }

    mod rf {
        incoming rs1 of Word<5>;
        incoming rs2 of Word<5>;
        incoming rd  of Word<5>;

        incoming write_enable of Word<1>;
        incoming write_data   of Word<32>;

        outgoing rs1_val of Word<32>;
        outgoing rs2_val of Word<32>;

        reg x0 of Word<32> reset 0w32;
        reg x1 of Word<32> reset 0w32;
        reg x2 of Word<32> reset 0w32;
        reg x3 of Word<32> reset 0w32;
        reg x4 of Word<32> reset 0w32;
        reg x5 of Word<32> reset 0w32;
        reg x6 of Word<32> reset 0w32;
        reg x7 of Word<32> reset 0w32;
        reg x8 of Word<32> reset 0w32;
        reg x9 of Word<32> reset 0w32;
        reg x10 of Word<32> reset 0w32;
        reg x11 of Word<32> reset 0w32;
        reg x12 of Word<32> reset 0w32;
        reg x13 of Word<32> reset 0w32;
        reg x14 of Word<32> reset 0w32;
        reg x15 of Word<32> reset 0w32;
        reg x16 of Word<32> reset 0w32;
        reg x17 of Word<32> reset 0w32;
        reg x18 of Word<32> reset 0w32;
        reg x19 of Word<32> reset 0w32;
        reg x20 of Word<32> reset 0w32;
        reg x21 of Word<32> reset 0w32;
        reg x22 of Word<32> reset 0w32;
        reg x23 of Word<32> reset 0w32;
        reg x24 of Word<32> reset 0w32;
        reg x25 of Word<32> reset 0w32;
        reg x26 of Word<32> reset 0w32;
        reg x27 of Word<32> reset 0w32;
        reg x28 of Word<32> reset 0w32;
        reg x29 of Word<32> reset 0w32;
        reg x30 of Word<32> reset 0w32;
        reg x31 of Word<32> reset 0w32;

        // skip x0
        x1 <= if write_enable && rd == 1w5 { write_data } else { x1 };
        x2 <= if write_enable && rd == 2w5 { write_data } else { x2 };
        x3 <= if write_enable && rd == 3w5 { write_data } else { x3 };
        x4 <= if write_enable && rd == 4w5 { write_data } else { x4 };
        x5 <= if write_enable && rd == 5w5 { write_data } else { x5 };
        x6 <= if write_enable && rd == 6w5 { write_data } else { x6 };
        x7 <= if write_enable && rd == 7w5 { write_data } else { x7 };
        x8 <= if write_enable && rd == 8w5 { write_data } else { x8 };
        x9 <= if write_enable && rd == 9w5 { write_data } else { x9 };
        x10 <= if write_enable && rd == 10w5 { write_data } else { x10 };
        x11 <= if write_enable && rd == 11w5 { write_data } else { x11 };
        x12 <= if write_enable && rd == 12w5 { write_data } else { x12 };
        x13 <= if write_enable && rd == 13w5 { write_data } else { x13 };
        x14 <= if write_enable && rd == 14w5 { write_data } else { x14 };
        x15 <= if write_enable && rd == 15w5 { write_data } else { x15 };
        x16 <= if write_enable && rd == 16w5 { write_data } else { x16 };
        x17 <= if write_enable && rd == 17w5 { write_data } else { x17 };
        x18 <= if write_enable && rd == 18w5 { write_data } else { x18 };
        x19 <= if write_enable && rd == 19w5 { write_data } else { x19 };
        x20 <= if write_enable && rd == 20w5 { write_data } else { x20 };
        x21 <= if write_enable && rd == 21w5 { write_data } else { x21 };
        x22 <= if write_enable && rd == 22w5 { write_data } else { x22 };
        x23 <= if write_enable && rd == 23w5 { write_data } else { x23 };
        x24 <= if write_enable && rd == 24w5 { write_data } else { x24 };
        x25 <= if write_enable && rd == 25w5 { write_data } else { x25 };
        x26 <= if write_enable && rd == 26w5 { write_data } else { x26 };
        x27 <= if write_enable && rd == 27w5 { write_data } else { x27 };
        x28 <= if write_enable && rd == 28w5 { write_data } else { x28 };
        x29 <= if write_enable && rd == 29w5 { write_data } else { x29 };
        x30 <= if write_enable && rd == 30w5 { write_data } else { x30 };
        x31 <= if write_enable && rd == 31w5 { write_data } else { x31 };

        rs1_val :=
                 if rs1 == 1w5 { x1 }
            else if rs1 == 2w5 { x2 }
            else if rs1 == 3w5 { x3 }
            else if rs1 == 4w5 { x4 }
            else if rs1 == 5w5 { x5 }
            else if rs1 == 6w5 { x6 }
            else if rs1 == 7w5 { x7 }
            else if rs1 == 8w5 { x8 }
            else if rs1 == 9w5 { x9 }
            else if rs1 == 10w5 { x10 }
            else if rs1 == 11w5 { x11 }
            else if rs1 == 12w5 { x12 }
            else if rs1 == 13w5 { x13 }
            else if rs1 == 14w5 { x14 }
            else if rs1 == 15w5 { x15 }
            else if rs1 == 16w5 { x16 }
            else if rs1 == 17w5 { x17 }
            else if rs1 == 18w5 { x18 }
            else if rs1 == 19w5 { x19 }
            else if rs1 == 20w5 { x20 }
            else if rs1 == 21w5 { x21 }
            else if rs1 == 22w5 { x22 }
            else if rs1 == 23w5 { x23 }
            else if rs1 == 24w5 { x24 }
            else if rs1 == 25w5 { x25 }
            else if rs1 == 26w5 { x26 }
            else if rs1 == 27w5 { x27 }
            else if rs1 == 28w5 { x28 }
            else if rs1 == 29w5 { x29 }
            else if rs1 == 30w5 { x30 }
            else if rs1 == 31w5 { x31 }
            else { 0w32 };

        rs2_val :=
                 if rs2 == 1w5 { x1 }
            else if rs2 == 2w5 { x2 }
            else if rs2 == 3w5 { x3 }
            else if rs2 == 4w5 { x4 }
            else if rs2 == 5w5 { x5 }
            else if rs2 == 6w5 { x6 }
            else if rs2 == 7w5 { x7 }
            else if rs2 == 8w5 { x8 }
            else if rs2 == 9w5 { x9 }
            else if rs2 == 10w5 { x10 }
            else if rs2 == 11w5 { x11 }
            else if rs2 == 12w5 { x12 }
            else if rs2 == 13w5 { x13 }
            else if rs2 == 14w5 { x14 }
            else if rs2 == 15w5 { x15 }
            else if rs2 == 16w5 { x16 }
            else if rs2 == 17w5 { x17 }
            else if rs2 == 18w5 { x18 }
            else if rs2 == 19w5 { x19 }
            else if rs2 == 20w5 { x20 }
            else if rs2 == 21w5 { x21 }
            else if rs2 == 22w5 { x22 }
            else if rs2 == 23w5 { x23 }
            else if rs2 == 24w5 { x24 }
            else if rs2 == 25w5 { x25 }
            else if rs2 == 26w5 { x26 }
            else if rs2 == 27w5 { x27 }
            else if rs2 == 28w5 { x28 }
            else if rs2 == 29w5 { x29 }
            else if rs2 == 30w5 { x30 }
            else if rs2 == 31w5 { x31 }
            else { 0w32 };
    }

    mod control {
        incoming opcode of Word<7>;
        incoming funct3 of Word<3>;
        incoming funct7 of Word<7>;

        outgoing branch of Word<1>;
        outgoing mem_read of Word<1>;
        outgoing mem_write of Word<1>;
        outgoing mem_to_reg of Word<1>;
        outgoing alu_op of Word<4>;
        outgoing alu_source of Word<1>;
        outgoing reg_write of Word<1>;

        node OP of Word<7>; OP := 51w7;
        node OP_IMM of Word<7>; OP_IMM := 19w7;
        node LOAD of Word<7>; LOAD := 3w7;
        node STORE of Word<7>; STORE := 35w7;
        node JAL of Word<7>; JAL := 111w7;
        node BRANCH of Word<7>; BRANCH := 99w7;
        node LUI of Word<7>; LUI := 55w7;
        node AUIPC of Word<7>; AUIPC := 23w7;
        node JALR of Word<7>; JALR := 103w7;

        branch := opcode == BRANCH || opcode == JALR || opcode == JAL;

        mem_read := opcode == LOAD;
        mem_write := opcode == STORE;
        mem_to_reg := mem_read;
        alu_op := if funct3 == 0w3 { // ADD/ADDI
            ALUOP_ADD
        } else {
            0w4
        };
        alu_source := opcode == OP_IMM || opcode == LOAD || opcode == STORE;
        reg_write := opcode == OP || opcode == OP_IMM || opcode == LOAD;

        node ALUOP_AND of Word<4>; ALUOP_AND := 0w4;
        node ALUOP_OR  of Word<4>; ALUOP_OR := 1w4;
        node ALUOP_ADD of Word<4>; ALUOP_ADD := 2w4;
        node ALUOP_SUB of Word<4>; ALUOP_SUB := 6w4;
    }

    instr_mem.write_enable := control.mem_write;
    instr_mem.write_addr := 0w16;
    instr_mem.write_data := rf.rs2_val[8..0];

    mod alu {
        incoming a of Word<32>;
        incoming b of Word<32>;
        incoming op of Word<4>;
        outgoing r of Word<32>;

        node AND of Word<4>; AND := 0w4;
        node OR  of Word<4>;  OR := 1w4;
        node ADD of Word<4>; ADD := 2w4;
        node SUB of Word<4>; SUB := 6w4;

        r := if op == AND {
            a && b
        } else if op == OR {
            a || b
        } else if op == ADD {
            a + b
        } else if op == SUB {
            a - b
        } else {
            0w32
        };
    }

    mod immgen {
        incoming instr of Word<32>;
        outgoing imm of Word<32>;

        node opcode of Word<32>;
        opcode := instr[7..0];

        node I_TYPE of Word<3>; I_TYPE := 1w3;
        node S_TYPE of Word<3>; S_TYPE := 2w3;
        node B_TYPE of Word<3>; B_TYPE := 3w3;
        node U_TYPE of Word<3>; U_TYPE := 4w3;
        node J_TYPE of Word<3>; J_TYPE := 5w3;

        node typ of Word<3>;
        typ := if opcode == 19w7 { // OP-IMM
            I_TYPE
        } else if opcode == 3w7 { // LOAD
            I_TYPE
        } else if opcode == 35w7 { // STORE
            S_TYPE
        } else if opcode == 111w7 { // JAL
            J_TYPE
        } else if opcode == 99w7 { // BRANCH
            B_TYPE
        } else if opcode == 55w7 { // LUI
            U_TYPE
        } else if opcode == 23w7 { // AUIPC
            U_TYPE
        } else if opcode == 103w7 { // JALR
            I_TYPE
        } else {
            0w3
        };

        node top of Word<1>;
        top := instr[31];

        imm := if typ == I_TYPE {
            sext(cat(instr[31], instr[32..20]), 32)
        } else if typ == S_TYPE {
            sext(cat(instr[31], instr[32..25], instr[12..7]), 32)
        } else if typ == B_TYPE {
            sext(cat(instr[31], instr[7], instr[31..25], instr[12..8], 0w1), 32)
        } else if typ == U_TYPE {
            sext(cat(instr[32..12], 0w12), 32)
        } else if typ == J_TYPE {
            sext(cat(instr[31], instr[20..12], instr[20], instr[31..21], 0w1), 32)
        } else {
            0w32
        };
    }

    mod decoder {
        incoming instr of Word<32>;

        outgoing opcode of Word<7>;
        outgoing rd  of Word<5>;
        outgoing rs1 of Word<5>;
        outgoing rs2 of Word<5>;
        outgoing funct3  of Word<3>;
        outgoing funct7  of Word<7>;

        opcode := instr[7..0];
        rd     := instr[12..7];
        funct3 := instr[15..12];
        rs1    := instr[20..15];
        rs2    := instr[25..20];
        funct7 := instr[32..25];
    }

    mod ifetch {
        incoming branch_offset of Word<32>;
        incoming branch_enable of Word<1>;

        outgoing instr_mem_addr of Word<32>;
        incoming instr_mem_data of Word<8>;

        outgoing instr_valid of Word<1>;
        outgoing instr of Word<32>;

        reg pc of Word<32> reset 0w32;
        instr_mem_addr := pc + tick;

        pc <= if tick == 3w2 {
            if branch_enable {
                pc + branch_offset
            } else {
                pc + 4w32
            }
        } else {
            pc
        };

        reg tick of Word<2> reset 0w2;
        tick <= tick + 1w2;

        reg instr_reg of Word<32> reset 0w32;
        instr := instr_reg;
        instr_reg <= cat(instr_mem_data, instr_reg[32..8]);

        reg is_first_cycle of Word<1> reset 1w1;
        is_first_cycle <= 0w1;
        instr_valid := tick == 0w2 && !is_first_cycle;
    }

    ifetch.branch_offset := 0w32;
    ifetch.branch_enable := 0w1;

    instr_mem.read_addr := ifetch.instr_mem_addr[16..0];
    ifetch.instr_mem_data := instr_mem.read_data;

    rf.rs1 := decoder.rs1;
    rf.rs2 := decoder.rs2;
    rf.rd := decoder.rd;
    rf.write_enable := control.reg_write;
    rf.write_data := alu.r;

    decoder.instr := ifetch.instr;
    immgen.instr := ifetch.instr;

    control.opcode := decoder.opcode;
    control.funct3 := decoder.funct3;
    control.funct7 := decoder.funct7;

    alu.a := rf.rs1_val;
    alu.b := if control.alu_source {
        immgen.imm
    } else {
        rf.rs2_val

    };
    alu.op := 2w4; // ADD
}

use super::*;

grammar;

pub Testbench: Testbench = {
    <commands:TestbenchCommand*> => Testbench(commands),
}

pub TestbenchCommand: TestbenchCommand = {
    "peek" <path:Path> => TestbenchCommand::Peek(path),
    "poke" <path:Path> <value:Value> => TestbenchCommand::Poke(path, value),
    "setreg" <path:Path> <value:Value> => TestbenchCommand::Set(path, value),
    "clock" => TestbenchCommand::Clock,
    "reset" => TestbenchCommand::Reset,
    "debug" => TestbenchCommand::Debug,
    "assert" <e:Expr> => TestbenchCommand::Assert(*e),
}

pub Top: Mod = {
    "top" "{"
        <decls:ModDecl*>
    "}" => Mod("top".to_string(), decls),
}

pub Mod: Mod = {
    "mod" <id:Id> "{"
        <decls:ModDecl*>
    "}" => Mod(id, decls),
}

pub ModDecl: ModDecl  = {
    "node" <id:Id> ";" => ModDecl::Node(id),
    "reg" <id:Id> <reset_val:("reset" Value)?> ";" => ModDecl::Reg(id, reset_val.map(|opt| opt.1).unwrap_or(Value::X)),
    "ext" <id:Id> "{"
        <nodes:("node" Id ";")+>
    "}" => {
        let names: Vec<String> = nodes.into_iter().map(|(_, name, _)| name).collect();
        ModDecl::Ext(id, names)
    },
    <m:Mod> => ModDecl::Mod(m),
    <path:Path> "<=" <e:Expr> ";" => ModDecl::Wire(path, *e),
}

pub Expr: Box<Expr> = {
    <e:ExprOr> => e,
}

pub ExprOr: Box<Expr> = {
    <e1:ExprAnd> "||" <e2:ExprOr> => Box::new(Expr::BinOp(BinOp::Or, e1, e2)),
    <e:ExprAnd> => e,
}

pub ExprAnd: Box<Expr> = {
    <e1:ExprNot> "&&" <e2:ExprAnd> => Box::new(Expr::BinOp(BinOp::And, e1, e2)),
    <e:ExprNot> => e,
}

pub ExprNot: Box<Expr> = {
    "!" <e:ExprEq> => Box::new(Expr::UnOp(UnOp::Not, e)),
    <e:ExprEq> => e,
}

pub ExprEq: Box<Expr> = {
    <e1:ExprAdd> "==" <e2:ExprEq> => Box::new(Expr::BinOp(BinOp::Eq,  e1, e2)),
    <e1:ExprAdd> "!=" <e2:ExprEq> => Box::new(Expr::BinOp(BinOp::Neq, e1, e2)),
    <e1:ExprAdd> "<" <e2:ExprEq> => Box::new(Expr::BinOp(BinOp::Lt, e1, e2)),
    <e:ExprAdd> => e,
}

pub ExprAdd: Box<Expr> = {
    <e1:ExprBase> "+" <e2:ExprAdd> => Box::new(Expr::BinOp(BinOp::Add, e1, e2)),
    <e1:ExprBase> "-" <e2:ExprAdd> => Box::new(Expr::BinOp(BinOp::Sub, e1, e2)),
    <e:ExprBase> => e,
}

pub ExprBase: Box<Expr> = {
    <e:ExprLit> => e,
    <e:ExprPath> => e,
    <e:ExprIf> => e,
    <e:ExprHole> => e,
    "(" <e:Expr> ")" => e,
}

pub ExprHole: Box<Expr> = {
    "?" <name:Id?> => Box::new(Expr::Hole(name)),
}

pub ExprIf: Box<Expr> = {
    "if" <cond:Expr> "{"
        <e1:Expr>
    "}" "else" "{"
        <e2:Expr>
    "}" => Box::new(Expr::If(cond, e1, e2)),
}

pub ExprLit: Box<Expr> = {
    <v:Value> => Box::new(Expr::Lit(v)),
}

pub ExprPath: Box<Expr> = {
     <id:Path> => Box::new(Expr::Path(id))
}

pub Value: Value = {
    "X" => Value::X,
    "true" => Value::Bit(true),
    "false" => Value::Bit(false),
    <lit:r"[0-9]+w[0-9]+"> => {
        let parts = lit.split("w").collect::<Vec<_>>();
        let v = parts[0].parse().unwrap();
        let width = parts[1].parse().unwrap();
        Value::Word(width, v)
    },
}

pub Nat: u64 = {
    <n:r"[0-9]+"> => n.parse().unwrap(),
}

pub Path: Path = {
    <id:Id> <dots:("." Id)*> => {
        let mut path = id;
        for (_, dot) in dots {
            path.push_str(".");
            path.push_str(&dot);
        }
        path.into()
    },
}

pub Id: String = {
    <id:r"[_A-Za-z][_A-Za-z0-9]*"> => id.to_string(),

    // This is required for the testbench parser, since "top" is a keyword in Nettle, but not in the testbench syntax.
    "top" => "top".to_string(),
}

match {
    r"//[^\n\r]*[\r\n]" => {},
    r"[\r\n]*" => {},
    r"/\*[^*]*\*/" => {},
    r" " => {},
    _,
}

use super::*;
use std::sync::Arc;
use once_cell::sync::OnceCell;

grammar(source_info: &SourceInfo);

pub Package: Vec<Decl> = {
    <decls:Decl*> => decls,
}

Decl: Decl = {
    <m:ModDef> => Decl::ModDef(m),
    <e:TypeDef> => Decl::TypeDef(e),
    <m:ExtDef> => Decl::ExtDef(m)
}

ModDef: Arc<Component> = {
    <ll:@L> "mod" <id:Id> "{"
        <decls:ModDecl*>
    "}" <rr:@R> => {
        let mut children = vec![];
        let mut wires = vec![];
        let mut whens = vec![];

        for decl in decls {
            match decl {
                ModDecl::Component(c) => children.push(c),
                ModDecl::Wire(w) => wires.push(w),
                ModDecl::When(w) => whens.push(w),
            }
        }

        Arc::new(Component::Mod(Loc::from(source_info, ll, rr), id, children, wires, whens))
    },
}

ExtDef: Arc<Component> = {
    <ll:@L> "ext" "mod" <id:Id> "{"
        <decls:ModDecl*>
    "}" <rr:@R> => {
        let mut children = vec![];
        // let mut wires = vec![]; // TODO

        for decl in decls {
            match decl {
                ModDecl::Component(c) => children.push(c),
                ModDecl::Wire(w) => panic!("Exts can't have wires {id}"),
                ModDecl::When(w) => panic!("Exts can't have whens {id}"),
            }
        }

        Arc::new(Component::Ext(Loc::from(source_info, ll, rr), id, children))
    },
}

TypeDef: Arc<TypeDef> = {
    <ll:@L> "enum" "type" <name:Id> "{"
        <values:(Id "=" WordLit ";")*>
    "}" <rr:@R> => {
        Arc::new(TypeDef {
            name,
            values: values.iter().map(|(n, _, v, _)| (n.clone(), v.clone())).collect::<Vec<_>>(),
        })
    },
}

Mod: Arc<Component> = {
    <ll:@L> "mod" <id:Id> "{"
        <decls:ModDecl*>
    "}" <rr:@R> => {
        let mut children = vec![];
        let mut wires = vec![];
        let mut whens = vec![];

        for decl in decls {
            match decl {
                ModDecl::Component(c) => children.push(c),
                ModDecl::Wire(w) => wires.push(w),
                ModDecl::When(w) => whens.push(w),
            }
        }

        Arc::new(Component::Mod(Loc::from(source_info, ll, rr), id, children, wires, whens))
    },
}

ModInst: Arc<Component> = {
    <ll:@L> "mod" <id:Id> "of" <modname:Id> ";" <rr:@R> => Arc::new(Component::ModInst(Loc::from(source_info, ll, rr), id, modname.into())),
}

ModDecl: ModDecl  = {
    <ll:@L> "incoming" <id:Id> "of" <typ:Type> ";" <rr:@R> => ModDecl::Component(Arc::new(Component::Incoming(Loc::from(source_info, ll, rr), id, typ))),
    <ll:@L> "outgoing" <id:Id> "of" <typ:Type> ";" <rr:@R> => ModDecl::Component(Arc::new(Component::Outgoing(Loc::from(source_info, ll, rr), id, typ))),
    <ll:@L> "node" <id:Id> "of" <typ:Type> ";" <rr:@R> => ModDecl::Component(Arc::new(Component::Node(Loc::from(source_info, ll, rr), id, typ))),
    <ll:@L> "reg" <id:Id>  "of" <typ:Type> <reset_val:("reset" Expr)?> ";" <rr:@R> => ModDecl::Component(Arc::new(Component::Reg(Loc::from(source_info, ll, rr), id, typ, reset_val.map(|opt| opt.1)))),
    <when:When> => ModDecl::When(when),
    <m:Mod> => ModDecl::Component(m),
    <m:ModInst> => ModDecl::Component(m),
    <wire:Wire> => ModDecl::Wire(wire),
}

Wire: Wire = {
    <ll:@L> <reference:Reference> ":=" <e:Expr> ";" <rr:@R> => Wire::new(Loc::from(source_info, ll, rr), reference, e, WireType::Direct),
    <ll:@L> <reference:Reference> "<=" <e:Expr> ";" <rr:@R> => Wire::new(Loc::from(source_info, ll, rr), reference, e, WireType::Latch),
    <ll:@L> <reference:Reference> "<=!" <e:Expr> ";" <rr:@R> => Wire::new(Loc::from(source_info, ll, rr), reference, e, WireType::Proc),
}

When: When = {
    "when" <e:Expr> "{"
        <wires:Wire*>
    "}" => When(e, wires),
}


pub Expr: Arc<Expr> = {
    <e:ExprOr> => e,
}

ExprOr: Arc<Expr> = {
    <ll:@L> <e1:ExprAnd> "||" <e2:ExprOr> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Or, e1, e2)),
    <ll:@L> <e1:ExprAnd> "^" <e2:ExprOr> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Xor, e1, e2)),
    <e:ExprAnd> => e,
}

ExprAnd: Arc<Expr> = {
    <ll:@L> <e1:ExprNot> "&&" <e2:ExprAnd> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::And, e1, e2)),
    <e:ExprNot> => e,
}

ExprNot: Arc<Expr> = {
    <ll:@L> "!" <e:ExprEq> <rr:@R> => Arc::new(Expr::UnOp(Loc::from(source_info, ll, rr), OnceCell::new(), UnOp::Not, e)),
    <e:ExprEq> => e,
}

ExprEq: Arc<Expr> = {
    <ll:@L> <e1:ExprAdd> "==" <e2:ExprEq> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Eq,  e1, e2)),
    <ll:@L> <e1:ExprAdd> "!=" <e2:ExprEq> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Neq, e1, e2)),
    <ll:@L> <e1:ExprAdd> "<" <e2:ExprEq> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Lt, e1, e2)),
    <e:ExprAdd> => e,
}

ExprAdd: Arc<Expr> = {
    <ll:@L> <e1:ExprCall> "+" <e2:ExprAdd> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Add, e1, e2)),
    <ll:@L> <e1:ExprCall> "+%" <e2:ExprAdd> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::AddCarry, e1, e2)),
    <ll:@L> <e1:ExprCall> "-" <e2:ExprAdd> <rr:@R> => Arc::new(Expr::BinOp(Loc::from(source_info, ll, rr), OnceCell::new(), BinOp::Sub, e1, e2)),
    <e:ExprCall> => e,
}

ExprCall: Arc<Expr> = {
    <ll:@L> "cat" "(" <e1:Expr> <ess:("," Expr)+> ")" <rr:@R> => {
        let mut es = vec![e1];
        for (_, e) in ess {
            es.push(e);
        }
        Arc::new(Expr::Cat(Loc::from(source_info, ll, rr), OnceCell::new(), es))
    },
    <ll:@L> "@Valid" "(" <e:Expr> ")" <rr:@R> => Arc::new(Expr::Ctor(Loc::from(source_info, ll, rr), OnceCell::new(), "Valid".to_string(), vec![e])),
    <ll:@L> "@Invalid" <rr:@R> => Arc::new(Expr::Ctor(Loc::from(source_info, ll, rr), OnceCell::new(), "Invalid".to_string(), vec![])),
    <ll:@L> "mux" "(" <cond:Expr> "," <e1:Expr> "," <e2:Expr> ")" <rr:@R> => Arc::new(Expr::Mux(Loc::from(source_info, ll, rr), OnceCell::new(), cond, e1, e2)),
    <ll:@L> "sext" "(" <e:Expr> "," <n:Nat> ")" <rr:@R> =>  Arc::new(Expr::Sext(Loc::from(source_info, ll, rr), OnceCell::new(), e, n)),
    <ll:@L> "word" "(" <e:Expr> ")" <rr:@R> =>  Arc::new(Expr::ToWord(Loc::from(source_info, ll, rr), OnceCell::new(), e)),
    <ll:@L> "[" <es:ExprList> "]" <rr:@R> => Arc::new(Expr::Vec(Loc::from(source_info, ll, rr), OnceCell::new(), es)),
    <ll:@L> "[" <e:Expr> ";" <n:Nat> "]" <rr:@R> => Arc::new(Expr::Vec(Loc::from(source_info, ll, rr), OnceCell::new(), vec![e; n as usize])),
    <ll:@L> <e:ExprBase> "[" <i:Nat> "]" <rr:@R> => Arc::new(Expr::Idx(Loc::from(source_info, ll, rr), OnceCell::new(), e, i)),
    <ll:@L> <e:ExprBase> "[" <j:Nat> ".." <i:Nat> "]" <rr:@R> => Arc::new(Expr::IdxRange(Loc::from(source_info, ll, rr), OnceCell::new(), e, j, i)),
//    <ll:@L> <e:ExprBase> "[" <i:Expr> "]" <rr:@R> => Arc::new(Expr::IdxDyn(Loc::from(source_info, ll, rr), OnceCell::new(), e, i)),
    <e:ExprBase> => e,
}

ExprList: Vec<Arc<Expr>> = {
    "" => vec![],
    <e:Expr> => vec![e],
    <e:Expr> "," <es:ExprList> => {
        let mut results = vec![e];
        results.extend(es.into_iter());
        results
    },
}

ExprBase: Arc<Expr> = {
    <e:ExprLit> => e,
    <e:ExprReference> => e,
    <e:ExprIf> => e,
    <e:ExprLet> => e,
    <e:ExprMatch> => e,
    <e:ExprHole> => e,
    "(" <e:Expr> ")" => e,
}

ExprHole: Arc<Expr> = {
    <ll:@L> "?" <name:Id?> <rr:@R> => Arc::new(Expr::Hole(Loc::from(source_info, ll, rr), OnceCell::new(), name)),
}

ExprIf: Arc<Expr> = {
    <ll:@L> "if" <cond:Expr> "{"
        <e1:Expr>
    <elseifs:("}" "else" "if" Expr "{" Expr)*>
    "}" "else" "{"
        <elseexpr:Expr>
    "}" <rr:@R> => {
        let mut result = elseexpr;

        for (_, _, _, elseif_cond, _, elseif_body) in elseifs.into_iter().rev() {
            result = Arc::new(Expr::If(Loc::from(source_info, ll, rr), OnceCell::new(), elseif_cond, elseif_body, result));
        }

        Arc::new(Expr::If(Loc::from(source_info, ll, rr), OnceCell::new(), cond, e1, result))
    },
}

ExprLet: Arc<Expr> = {
    <ll:@L> "let" <x:Id> "=" <e:Expr>
    "{" <b:Expr> "}" <rr:@R> => {
        Arc::new(Expr::Let(Loc::from(source_info, ll, rr), OnceCell::new(), x, e, b))
    },
}

ExprMatch: Arc<Expr> = {
    <ll:@L> "match" <e:Expr> "{"
        <arms:MatchArm*>
    "}" <rr:@R> => {
        Arc::new(Expr::Match(Loc::from(source_info, ll, rr), OnceCell::new(), e, arms))
    },
}

MatchArm: MatchArm = {
    <pat:Pat> "=>" <e:Expr> ";" => MatchArm(pat, e),
}

Pat: Pat = {
    "@" <id:Id> => Pat::At(id.to_string(), vec![]),
    "@" <id:Id> "(" <p:Pat> <ps:("," Pat)+> ")" => {
        let mut subpats = vec![p];
        subpats.extend(ps.iter().map(|(_, pat)| pat.clone()));
        Pat::At(id.to_string(), subpats)
    },
    <id:Id> => Pat::Bind(id.to_string()),
    "otherwise" => Pat::Otherwise,
}

ExprLit: Arc<Expr> = {
    <ll:@L> <typename:Id> "::" <name:Id> <rr:@R> =>
        Arc::new(Expr::Enum(Loc::from(source_info, ll, rr), OnceCell::new(), typename.into(), name.to_string())),

    <ll:@L> <lit:WordLit> <rr:@R> => {
        let WordLit(w, v) = lit;
        Arc::new(Expr::Word(Loc::from(source_info, ll, rr), OnceCell::new(), w, v))
    },
}

WordLit: WordLit = {
    <n:Nat> => WordLit(None, n),

    <lit:r"[0-9]+w[0-9]+"> => {
        let parts = lit.split("w").collect::<Vec<_>>();
        let v = parts[0].parse().unwrap();
        let width = parts[1].parse().unwrap();
        WordLit(Some(width), v)
    },

    <lit:r"0b[0-1]+w[0-9]+"> => {
        let parts = lit.split("w").collect::<Vec<_>>();
        let v = u64::from_str_radix(&parts[0][2..], 2).unwrap();
        let width = parts[1].parse().unwrap();
        WordLit(Some(width), v)
    },

    <lit:r"0x[0-9a-fA-F]+w[0-9]+"> => {
        let parts = lit.split("w").collect::<Vec<_>>();
        let v = u64::from_str_radix(&parts[0][2..], 16).unwrap();
        let width = parts[1].parse().unwrap();
        WordLit(Some(width), v)
    },
}

ExprReference: Arc<Expr> = {
     <ll:@L> <path:Path> <rr:@R> => Arc::new(Expr::Reference(Loc::from(source_info, ll, rr), OnceCell::new(), path.into()))
}

Type: Arc<Type> = {
    "Word" "<" <n:Nat> ">" => Arc::new(Type::Word(n)),
    "Valid" "<" <typ:Type> ">" => Arc::new(Type::Valid(typ.clone())),
    <id:Id> => Arc::new(Type::TypeDef(id.into())),
    "Vec" "<" <typ:Type> "," <n:Nat> ">" => Arc::new(Type::Vec(typ.clone(), n)),
}

Nat: u64 = {
    <n:r"[0-9]+"> => n.parse().unwrap(),
    <n:r"0b[0-9]+"> => u64::from_str_radix(&n[2..], 2).unwrap(),
    <n:r"0x[0-9]+"> => u64::from_str_radix(&n[2..], 16).unwrap(),
}

Path: Path = {
    <id:Id> <dots:("." Id)*> => {
        let mut path = id;
        for (_, dot) in dots {
            path.push_str(".");
            path.push_str(&dot);
        }
        path.into()
    },
}

Reference: Path = {
    <submod:Id> "." <id:Id> => format!("{submod}.{id}").into(),
    <id:Id> => id.into(),
}

Str: String = {
    <s:r#""[^"]*""#> => s[1..s.len()-1].to_string(),
}

Id: String = {
    <id:r"[_A-Za-z][_A-Za-z0-9]*"> => id.to_string(),
}

match {
    r"//[^\n\r]*[\r\n]" => {},
    r"[\r\n]*" => {},
    r"/\*[^*]*\*/" => {},
    r" " => {},
    _,
}

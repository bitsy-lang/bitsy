use crate::ast::*;
use std::sync::Arc;

grammar;

pub Circuit: Circuit = {
    <decls:Decl*> => Circuit {
        decls,
    }
}

pub Decl: Decl = {
    <mod_def:ModDef> => {
        Decl::ModDef(Arc::new(mod_def))
    },
    <enum_def:EnumDef> => {
        Decl::EnumDef(Arc::new(enum_def))
    }
}

pub ModDef: ModDef = {
    <visibility:Visibility> "mod" <name:Ident>
        <ports: Port*>
        <components: Component*>
        <wires: Wire*>
    "end"
    =>
        ModDef {
            name,
            visibility,
            ports,
            components,
            wires,
        }
}

pub EnumDef: EnumDef = {
    <visibility:Visibility> "enum" "type" <name:Ident>
        <alts:EnumAlt*>
    "end"
    => {
        EnumDef {
            name,
            visibility,
            alts,
        }
    }
}

pub EnumAlt: EnumAlt = {
    <ctor_name:Ctor> <payload_shape:("of" <Shape>)?> => {
        EnumAlt {
            ctor_name,
            payload_shape,
        }
    }
}

pub Port: Port = {
    <direction:Direction> <name:Ident> ":" <shape:Shape> "@" <domain:Domain>
    => Port(name, direction, shape, domain)
}

pub Direction: Direction = {
    "incoming" => Direction::Incoming,
    "outgoing" => Direction::Outgoing,
}

pub Shape: Shape = {
    <ident:Ident> "<" <shape_params:ShapeParams> ">" => Shape(ident, shape_params),
    <ident:Ident> => Shape(ident, vec![]),
}

pub ShapeParams: Vec<ShapeParam> = {
    <shape_param0:ShapeParam> <shape_param_rest:("," ShapeParam)*> => {
        let mut result = vec![shape_param0];
        for (_s, shape_param) in shape_param_rest {
            result.push(shape_param);
        }
        result
    }
}

pub ShapeParam: ShapeParam = {
    <n:Nat> => ShapeParam::Nat(n),
    <shape:Shape> => ShapeParam::Shape(Arc::new(shape)),
}

pub Domain: Domain = {
    "d" => Domain
}


pub Component: Component = {
    <visibility:Visibility> "reg" <ident:Ident> "of" <shape:Shape> "@" <domain:Domain> <init:RegInit?> => {
        Component::Reg(
            ident,
            Visibility::Public,
            RegComponent {
                shape,
                domain ,
                init: init.unwrap_or(Value::Unobservable),
            }
        )
    },

    <visibility:Visibility> "mod" <ident:Ident> "of" <moddef_name:ModDefName> => {
        Component::Mod(
            ident,
            Visibility::Public,
            ModComponent {
                moddef_name,
            }
        )
    },

    <visibility:Visibility> "gate" <ident:Ident> "of" <gate_name:GateName> => {
        Component::Gate(
            ident,
            Visibility::Public,
            GateComponent {
                gate_name,
            }
        )
    },
}

pub RegInit: Value = {
    "init" <value: Value> => value
}

pub Nat: u64 = {
    <n:r"[0-9]+"> => n.parse().unwrap(),
}

pub Value: Value = {
    "true" => Value::Bool(true),
    "false" => Value::Bool(false),
    <n:r"[0-9]+"> => Value::Word(n.parse().unwrap()),
    "tuple" "(" <elts:TupleElts?>")" => Value::Tuple(elts.unwrap_or_default()),
}

pub TupleElts: Vec<Box<Value>> = {
    <v0:Value> <v_rest:("," <Value>)*> => {
        let mut result = vec![Box::new(v0)];
        for v in v_rest {
            result.push(Box::new(v));
        }
        result
    }
}

pub Visibility: Visibility = {
    <visibility:"pub"?> => if visibility.is_some() { Visibility::Public } else { Visibility::Private }
}

pub ModDefName: String = {
    <ident:Ident> => ident.to_string()
}

pub GateName: String = {
    <ident:Ident> => ident.to_string()
}

pub Wire: Wire = {
    <visibility:Visibility> "wire" <sink:Terminal> "<=" <source:Terminal> => {
        Wire::Simple(visibility, sink, source)
    },
    <visibility:Visibility> "wire" <sink:Terminal> "<=" "{" <expr:Expr> "}" => {
        Wire::Expr(visibility, sink, expr)
    },
}

pub Expr: Arc<Expr> = {
    <op0:Term> "+" <op1:Expr> => Arc::new(Expr::Add(op0, op1)),
    <expr:Term> => expr,
}

pub Term: Arc<Expr> = {
    <op0:Factor> "*" <op1: Term> => Arc::new(Expr::Mul(op0, op1)),
    <expr:Factor> => expr,
}

pub Factor: Arc<Expr> = {
    <terminal:Terminal> => Arc::new(Expr::Term(terminal)),
    <value:Value> => Arc::new(Expr::Lit(value)),
    "(" <expr:Expr> ")" => expr,
}

pub Terminal: Terminal = {
    <component_name:Ident> "." <port_name:Ident> => Terminal(component_name, port_name)
}

pub Ctor: String = {
    "@" <name:Ident> => name,
}

pub Ident: String = {
    <ident:r"[_A-Za-z][_A-Za-z0-9]*"> => ident.to_string()
}

match {
    r"#[^\n\r]*[\r\n]" => {},
    r"[\r\n]*" => {},
    r" " => {},
    _,
}

use crate::ast::*;

grammar;

pub Namespace: Namespace = {
    <decls:Decl*> => Namespace {
        decls,
    }
}

pub Decl: Decl = {
    <mod_def:ModDef> => {
        Decl::ModDef(mod_def)
    },
    <enum_def:EnumDef> => {
        Decl::EnumDef(enum_def)
    },
    <struct_def:StructDef> => {
        Decl::StructDef(struct_def)
    },
}

pub ModDef: ModDef = {
    <visibility:Visibility> "mod" <name:Ident>
        <ports: Port*>
        <components: Component*>
        <wires: Wire*>
    "end"
    =>
        ModDef {
            name,
            visibility,
            ports,
            components,
            wires,
        }
}

pub StructDef: StructDef = {
    <visibility:Visibility> "struct" "type" <name:Ident> <params:TypeDefParams?>
        <fields:StructField*>
    "end"
    => {
        StructDef {
            name,
            params: params.unwrap_or(vec![]),
            visibility,
            fields,
        }
    }
}

pub StructField: StructField = {
    "field" <ident:Ident> ":" <shape:Shape> => StructField(ident, shape),
}

pub EnumDef: EnumDef = {
    <visibility:Visibility> "enum" "type" <name:Ident> <params:TypeDefParams?>
        <alts:EnumAlt*>
    "end"
    => {
        EnumDef {
            name,
            params: params.unwrap_or(vec![]),
            visibility,
            alts,
        }
    }
}

pub TypeDefParams: Vec<ShapeDefParam> = {
    "<" <param0:TypeDefParam> <param_rest:("," TypeDefParam)*> ">" => {
        let mut result = vec![param0];
        for (_s, param) in param_rest {
            result.push(param);
        }
        result
    },
}

pub TypeDefParam: ShapeDefParam = {
    <ident:Ident> ":" "Nat" => ShapeDefParam::Nat(ident),
    <ident:Ident> ":" "Shape" => ShapeDefParam::Shape(ident),
}

pub EnumAlt: EnumAlt = {
    <ctor_name:Ctor> <payload_shape:("of" <Shape>)?> => {
        EnumAlt {
            ctor_name,
            payload_shape,
        }
    }
}

pub Port: Port = {
    <direction:Direction> <name:Ident> ":" <shape:Shape> "@" <domain:Domain>
    => Port(name, direction, shape, domain)
}

pub Direction: Direction = {
    "incoming" => Direction::Incoming,
    "outgoing" => Direction::Outgoing,
}

pub Shape: ShapeRef = {
    <ident:Ident> "<" <shape_params:ShapeParams> ">" => ShapeRef(ident, shape_params),
    <ident:Ident> => ShapeRef(ident, vec![]),
}

pub ShapeParams: Vec<ShapeParam> = {
    <shape_param0:ShapeParam> <shape_param_rest:("," ShapeParam)*> => {
        let mut result = vec![shape_param0];
        for (_s, shape_param) in shape_param_rest {
            result.push(shape_param);
        }
        result
    }
}

pub ShapeParam: ShapeParam = {
    <n:Nat> => ShapeParam::Nat(n),
    <shape:Shape> => ShapeParam::Shape(shape),
}

pub Domain: Domain = {
    "d" => Domain
}


pub Component: Component = {
    <visibility:Visibility> "reg" <ident:Ident> "of" <shape:Shape> "@" <domain:Domain> <init:RegInit?> => {
        Component::Reg(
            ident,
            Visibility::Public,
            RegComponent {
                shape,
                domain ,
                init: init.unwrap_or(Value::Unobservable),
            }
        )
    },

    <visibility:Visibility> "mod" <ident:Ident> "of" <moddef_name:ModDefName> => {
        Component::Mod(
            ident,
            Visibility::Public,
            ModComponent {
                moddef_name,
            }
        )
    },

    <visibility:Visibility> "gate" <ident:Ident> "of" <gate_name:GateName> => {
        Component::Gate(
            ident,
            Visibility::Public,
            GateComponent {
                gate_name,
            }
        )
    },
}

pub RegInit: Value = {
    "init" <value: Value> => value
}

pub Nat: u64 = {
    <n:r"[0-9]+"> => n.parse().unwrap(),
}

pub Value: Value = {
    "true" => Value::Bit(true),
    "false" => Value::Bit(false),
    <n:r"[0-9]+"> => Value::Word(n.parse().unwrap()),
    "tuple" "(" <elts:TupleElts?>")" => Value::Tuple(elts.unwrap_or_default()),
}

pub TupleElts: Vec<Box<Value>> = {
    <v0:Value> <v_rest:("," <Value>)*> => {
        let mut result = vec![Box::new(v0)];
        for v in v_rest {
            result.push(Box::new(v));
        }
        result
    }
}

pub Visibility: Visibility = {
    <visibility:"pub"?> => if visibility.is_some() { Visibility::Public } else { Visibility::Private }
}

pub ModDefName: String = {
    <ident:Ident> => ident.to_string()
}

pub GateName: String = {
    <ident:Ident> => ident.to_string()
}

pub Wire: Wire = {
    <visibility:Visibility> "wire" <sink:Terminal> "<=" <source:Terminal> => {
        Wire::Simple(visibility, sink, source)
    },
    <visibility:Visibility> "wire" <sink:Terminal> "<=" "{" <expr:Expr> "}" => {
        Wire::Expr(visibility, sink, expr)
    },
}

pub Expr: Box<Expr> = {
    "let" <v:Ident> <shape:(":" Shape)?> "=" <def:Expr> ";" <body:Expr> => Box::new(Expr::Let(v, def, shape.map(|x| x.1), body)),
    "match" <subject:Expr> "{"
        <patterns:MatchArm*>
    "}" => Box::new(Expr::Match(subject, patterns)),
    <op0:Term> "+" <op1:Expr> => Box::new(Expr::Add(op0, op1)),
    <expr:Term> => expr,
}

pub MatchArm: MatchArm = {
    <pattern:MatchPattern> "=>" <expr:Expr> => MatchArm(pattern, expr)
}

pub MatchPattern: Box<MatchPattern> = {
    <ctor:Ctor> <args: MatchPatternArgs?> => Box::new(MatchPattern::Ctor(ctor, args.unwrap_or(vec![]))),
    <v:Ident> => Box::new(MatchPattern::Var(v)),
    <v:Value> => Box::new(MatchPattern::Lit(v)),
    "otherwise" => Box::new(MatchPattern::Otherwise),
}

pub MatchPatternArgs: Vec<Box<MatchPattern>> = {
    "(" <first:MatchPattern> <rest:("," MatchPattern)*> ")" => {
        let mut results = vec![first];
        for pat in rest {
            results.push(pat.1);
        }
        results
    }
}

pub Term: Box<Expr> = {
    <op0:Factor> "*" <op1: Term> => Box::new(Expr::Mul(op0, op1)),
    <expr:Factor> => expr,
}

pub Factor: Box<Expr> = {
    <terminal:Terminal> => Box::new(Expr::Term(terminal)),
    <name:Ident> => Box::new(Expr::Term(Terminal("__temp".to_string(), name))),
    <value:Value> => Box::new(Expr::Lit(value)),
    "(" <expr:Expr> ")" => expr,
}

pub Terminal: Terminal = {
    <component_name:Ident> "." <port_name:Ident> => Terminal(component_name, port_name)
}

pub Ctor: String = {
    "@" <name:Ident> => name,
}

pub Ident: String = {
    <ident:r"[_A-Za-z][_A-Za-z0-9]*"> => ident.to_string()
}

match {
    r"//[^\n\r]*[\r\n]" => {},
    r"[\r\n]*" => {},
    r" " => {},
    _,
}
